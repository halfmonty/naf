{"version":3,"file":"index-6iOQs0yA.js","sources":["../../../naf.ts","../../src/components/Card.ts","../../src/components/Home.ts","../../src/components/Header.ts","../../src/components/AddTodoForm.ts","../../src/components/FilterButtons.ts","../../src/components/TodoItem.ts","../../src/components/TodoList.ts","../../src/components/EmptyState.ts","../../src/components/Stats.ts","../../src/components/TodoPage.ts","../../src/components/Nav.ts","../../src/main.ts"],"sourcesContent":["// ============================================================================\n// NAF (Not A Framework) - Vanilla SPA Helper Functions\n// ============================================================================\n// A ~1.3KB gzipped reactive framework for building SPAs with zero dependencies.\n// Simplified Set-based reactivity optimized for small to medium websites.\n// ============================================================================\n\n// ============================================================================\n// TYPE DEFINITIONS\n// ============================================================================\n\n/**\n * Component interface - represents a mountable piece of UI.\n *\n * @template T - The type of the root element (defaults to Element)\n */\nexport interface Component<T extends Element = Element> {\n  /** HTML string to render */\n  html: string;\n  /** Optional DOM reference (populated if root selector used) */\n  el?: T;\n  /** Called when component enters DOM */\n  mount: (parent: Element) => void;\n  /** Called when component leaves DOM */\n  unmount?: () => void;\n}\n\n/**\n * Options for template function when using root selector and lifecycle hooks.\n *\n * @template T - The type of the root element\n */\ninterface TemplateOptions<T extends Element = Element> {\n  /** CSS selector for the root element to capture in el property */\n  root?: string;\n  /** Called after component is mounted */\n  onMount?: (el: T | undefined, parent: Element) => void;\n  /** Called before component is unmounted */\n  onUnmount?: () => void;\n}\n\n/**\n * Options for template function WITH root selector - guarantees el is non-null.\n *\n * @template T - The type of the root element\n */\ninterface TemplateOptionsWithRoot<T extends Element = Element> {\n  /** CSS selector for the root element to capture in el property */\n  root: string;\n  /** Called after component is mounted - el is guaranteed to exist */\n  onMount?: (el: T, parent: Element) => void;\n  /** Called before component is unmounted */\n  onUnmount?: () => void;\n}\n\n/** Valid values that can be interpolated in templates */\ntype TemplateValue = Component | string | number | boolean | null | undefined;\n\n/**\n * Signal type - a reactive getter/setter function.\n * Use this type for function parameters and props instead of verbose function signatures.\n *\n * @example\n * // Instead of: props: { count: () => number }\n * // Use: props: { count: Signal<number> }\n */\nexport type Signal<T> = { (): T; (value: T): T };\n\n/**\n * Computed type - a reactive getter-only function.\n * Use this type for computed values in function parameters and props.\n *\n * @example\n * // Instead of: props: { doubled: () => number }\n * // Use: props: { doubled: Computed<number> }\n */\nexport type Computed<T> = () => T;\n\n// ============================================================================\n// REACTIVITY SYSTEM\n// ============================================================================\n\ntype Subs = Set<() => void>;\n\nlet activeSub: (() => void) | undefined;\nlet activeSets: Subs[] | undefined;\n\n/** Tracks the current subscriber with a dependency set */\nconst track = (subs: Subs) => {\n  if (activeSub) {\n    subs.add(activeSub);\n    activeSets?.push(subs);\n  }\n};\n\n/** Notifies all subscribers in a set */\nconst notify = (subs: Subs) => [...subs].forEach((fn) => fn());\n\n/**\n * Creates a reactive signal that holds a value.\n *\n * Signals are both getters and setters:\n * - Call with no arguments to read: `count()`\n * - Call with a value to write: `count(5)`\n *\n * Only notifies subscribers if the value changes (uses !== comparison).\n *\n * @example\n * const count = signal(0);\n * console.log(count()); // 0\n * count(5);             // Set value\n * console.log(count()); // 5\n */\nexport function signal<T>(initialValue: T): Signal<T> {\n  let value = initialValue;\n  const subs: Subs = new Set();\n\n  return function (newValue?: T): T {\n    if (arguments.length > 0) {\n      if (value !== newValue) {\n        value = newValue!;\n        notify(subs);\n      }\n      return newValue!;\n    }\n    track(subs);\n    return value;\n  } as { (): T; (value: T): T };\n}\n\n/**\n * Creates a computed value that automatically tracks dependencies.\n *\n * Computed values:\n * - Only recompute when dependencies change (lazy evaluation)\n * - Cache their result until marked dirty\n * - Automatically track all signals/computeds accessed\n *\n * @example\n * const count = signal(5);\n * const doubled = computed(() => count() * 2);\n * console.log(doubled()); // 10\n * count(10);\n * console.log(doubled()); // 20\n */\nexport function computed<T>(fn: () => T): Computed<T> {\n  let value: T;\n  let dirty = true;\n  const subs: Subs = new Set();\n\n  const markDirty = () => {\n    dirty = true;\n    notify(subs);\n  };\n\n  return () => {\n    track(subs);\n    if (dirty) {\n      const prevSub = activeSub;\n      activeSub = markDirty;\n      value = fn();\n      activeSub = prevSub;\n      dirty = false;\n    }\n    return value;\n  };\n}\n\n/**\n * Creates an effect that runs when dependencies change.\n *\n * Effects:\n * - Run immediately on creation\n * - Re-run whenever accessed signals/computeds change\n * - Automatically track dependencies (no manual subscription)\n * - Return a cleanup function to stop tracking\n *\n * @example\n * const count = signal(0);\n * const cleanup = effect(() => {\n *   console.log(`Count: ${count()}`);\n * });\n * count(5); // Logs: \"Count: 5\"\n * cleanup(); // Stop tracking\n */\nexport function effect(fn: () => void): () => void {\n  let running = false;\n  const subscribedTo: Subs[] = [];\n\n  const run = () => {\n    if (running) return;\n    running = true;\n\n    // Clear previous subscriptions before re-running\n    subscribedTo.forEach((set) => set.delete(run));\n    subscribedTo.length = 0;\n\n    const prevSub = activeSub;\n    const prevSets = activeSets;\n    activeSub = run;\n    activeSets = subscribedTo;\n    fn();\n    activeSub = prevSub;\n    activeSets = prevSets;\n    running = false;\n  };\n\n  run();\n\n  return () => {\n    subscribedTo.forEach((set) => set.delete(run));\n    subscribedTo.length = 0;\n  };\n}\n\n// ============================================================================\n// COMPONENT SYSTEM\n// ============================================================================\n\n/**\n * Escapes HTML to prevent XSS attacks. Always use for user-provided content.\n *\n * @example\n * const userInput = '<script>alert(\"xss\")</script>';\n * template`<p>${text(userInput)}</p>`;\n * // Renders safe: <p>&lt;script&gt;...&lt;/script&gt;</p>\n */\nexport function text(str: string): string {\n  return str\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#39;\");\n}\n\n/** Type guard to check if a value is a Component */\nfunction isComponent(value: unknown): value is Component {\n  return (\n    value != null &&\n    typeof value === \"object\" &&\n    \"html\" in value &&\n    \"mount\" in value\n  );\n}\n\n/** Builds HTML string and extracts components from template parts */\nfunction buildTemplate(\n  strings: TemplateStringsArray,\n  values: TemplateValue[],\n): { html: string; components: Component[] } {\n  const components: Component[] = [];\n  const parts: string[] = [strings[0]];\n\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (isComponent(value)) {\n      components.push(value);\n      parts.push(value.html);\n    } else if (typeof value === \"string\") {\n      // Plain strings are treated as raw HTML without component wrapper\n      parts.push(value);\n    } else if (value != null && value !== false) {\n      parts.push(String(value));\n    }\n    parts.push(strings[i + 1]);\n  }\n\n  return { html: parts.join(\"\"), components };\n}\n\n/** Creates a component with mount/unmount logic and lifecycle hooks */\nfunction createComponent<T extends Element>(\n  html: string,\n  components: Component[],\n  options?: TemplateOptions<T>,\n): Component<T> {\n  const component: Component<T> = {\n    html,\n    el: undefined,\n    mount(parent: Element) {\n      if (!parent.innerHTML) {\n        parent.innerHTML = html;\n      }\n      for (const c of components) c.mount(parent);\n      if (options?.root) {\n        const foundEl = parent.querySelector<T>(options.root);\n        if (!foundEl) {\n          throw new Error(`Element not found for selector: ${options.root}`);\n        }\n        component.el = foundEl;\n      }\n      options?.onMount?.(component.el as T, parent);\n    },\n    unmount() {\n      for (const c of components) c.unmount?.();\n      options?.onUnmount?.();\n    },\n  };\n  return component;\n}\n\n/** Counter for generating unique slot IDs */\nlet slotId = 0;\n\n/** Reusable temporary element for parsing HTML strings */\nconst tempDiv = document.createElement(\"div\");\n\n/**\n * Updates content between comment markers in a reactive slot.\n * Removes old content and inserts new HTML between start and end markers.\n */\nfunction updateSlotContent(\n  placeholder: Comment,\n  commentId: string,\n  html: string,\n): void {\n  const parent = placeholder.parentNode!;\n\n  // Find end marker\n  let node = placeholder.nextSibling;\n  while (node && node.textContent !== `/naf-${commentId}`) {\n    node = node.nextSibling;\n  }\n  const end = node;\n\n  // Remove old content (everything between markers)\n  node = placeholder.nextSibling;\n  while (node && node !== end) {\n    const next = node.nextSibling;\n    parent.removeChild(node);\n    node = next;\n  }\n\n  // Insert new content\n  if (html) {\n    tempDiv.innerHTML = html;\n    while (tempDiv.firstChild) {\n      parent.insertBefore(tempDiv.firstChild, end);\n    }\n  }\n}\n\n/** Creates a reactive slot placeholder for dynamic content (used by when/each) */\nfunction reactiveSlot(\n  dataAttr: string,\n  setupEffect: (placeholder: Comment) => () => void,\n): Component {\n  const id = slotId++;\n  let cleanup: (() => void) | undefined;\n  const html = `<!--naf-${id}--><!--/naf-${id}-->`;\n\n  return {\n    html,\n    mount(parent: Element) {\n      // Ensure HTML is in DOM first\n      if (!parent.innerHTML) {\n        parent.innerHTML = html;\n      }\n\n      // Find comment node with matching id\n      const walker = document.createTreeWalker(\n        parent,\n        NodeFilter.SHOW_COMMENT,\n        null,\n      );\n      let placeholder: Comment | null = null;\n      let endMarker: Comment | null = null;\n      let node: Node | null;\n      while ((node = walker.nextNode())) {\n        if (node.textContent === `naf-${id}`) {\n          placeholder = node as Comment;\n        } else if (node.textContent === `/naf-${id}`) {\n          endMarker = node as Comment;\n          break;\n        }\n      }\n      if (!placeholder || !endMarker) {\n        throw new Error(`Could not find placeholder comments: naf-${id}`);\n      }\n      cleanup = setupEffect(placeholder);\n    },\n    unmount() {\n      cleanup?.();\n    },\n  };\n}\n\n/**\n * Tagged template for creating components with automatic child management.\n *\n * Can be called two ways:\n * 1. Direct: template`<div>...</div>`\n * 2. With options: template({ root: '#id' })`<div>...</div>`\n *\n * @example\n * // Basic usage\n * function Header() {\n *   return template`<h1>My App</h1>`;\n * }\n *\n * @example\n * // With lifecycle hooks\n * function Counter() {\n *   const count = signal(0);\n *   return template({\n *     root: '#counter',\n *     onMount(el) {\n *       effect(() => {\n *         if (el) el.textContent = `Count: ${count()}`;\n *       });\n *     }\n *   })`<div id=\"counter\"></div>`;\n * }\n */\nexport function template<T extends Element = Element>(\n  options: TemplateOptionsWithRoot<T>,\n): (strings: TemplateStringsArray, ...values: TemplateValue[]) => Component<T>;\nexport function template<T extends Element = Element>(\n  options: TemplateOptions<T>,\n): (strings: TemplateStringsArray, ...values: TemplateValue[]) => Component<T>;\nexport function template(\n  strings: TemplateStringsArray,\n  ...values: TemplateValue[]\n): Component;\nexport function template<T extends Element = Element>(\n  optionsOrStrings: TemplateOptions<T> | TemplateStringsArray,\n  ...valuesOrNothing: TemplateValue[]\n):\n  | Component<T>\n  | ((\n      strings: TemplateStringsArray,\n      ...values: TemplateValue[]\n    ) => Component<T>) {\n  if (\n    !Array.isArray(optionsOrStrings) &&\n    typeof optionsOrStrings === \"object\" &&\n    !(\"raw\" in optionsOrStrings)\n  ) {\n    const options = optionsOrStrings as TemplateOptions<T>;\n    return (strings: TemplateStringsArray, ...values: TemplateValue[]) => {\n      const { html, components } = buildTemplate(strings, values);\n      return createComponent(html, components, options);\n    };\n  }\n\n  const strings = optionsOrStrings as TemplateStringsArray;\n  const values = valuesOrNothing;\n  const { html, components } = buildTemplate(strings, values);\n  return createComponent(html, components);\n}\n\n/**\n * Conditional rendering based on a reactive condition.\n *\n * Efficiently renders different components based on a truthy/falsy value.\n * Automatically unmounts the previous component before mounting the new one.\n * Passes the condition result to callbacks to avoid double computation.\n *\n * @example\n * const isLoggedIn = signal(false);\n * template`\n *   <div>\n *     ${when(\n *       () => isLoggedIn(),\n *       () => template`<p>Welcome back!</p>`,\n *       () => template`<p>Please log in</p>`\n *     )}\n *   </div>\n * `;\n *\n * @example\n * // Avoid double computation by using the passed value\n * const filteredTodos = computed(() => todos().filter(t => !t.done));\n * template`\n *   ${when(\n *     () => filteredTodos(),\n *     (todos) => TodoList({ todos }),  // Uses passed value, no re-computation\n *     () => template`<p>No todos</p>`\n *   )}\n * `;\n */\nexport function when<T>(\n  condition: () => T,\n  then: (value: T) => Component,\n  otherwise?: (value: T) => Component,\n): Component {\n  let currentComponent: Component | undefined;\n\n  return reactiveSlot(\"when\", (placeholder) => {\n    // Capture id from comment node\n    const commentId = placeholder.textContent?.replace(\"naf-\", \"\") || \"0\";\n\n    const stopEffect = effect(() => {\n      currentComponent?.unmount?.();\n      const value = condition();\n      currentComponent = value ? then(value) : otherwise?.(value);\n\n      const html = currentComponent?.html ?? \"\";\n      updateSlotContent(placeholder, commentId, html);\n      currentComponent?.mount(placeholder.parentNode as Element);\n    });\n\n    return () => {\n      stopEffect();\n      currentComponent?.unmount?.();\n    };\n  });\n}\n\n/**\n * Reactive list rendering that re-renders when the array changes.\n *\n * Note: Re-renders ALL items when the array changes (no keyed diffing).\n *\n * @example\n * const todos = signal([\n *   { id: 1, text: 'Learn NAF' },\n *   { id: 2, text: 'Build app' }\n * ]);\n *\n * template`\n *   <ul>\n *     ${each(\n *       () => todos(),\n *       (todo) => template`<li>${text(todo.text)}</li>`\n *     )}\n *   </ul>\n * `;\n */\nexport function each<T>(\n  items: () => T[],\n  render: (item: T, index: () => number) => Component,\n): Component {\n  let components: Component[] = [];\n\n  return reactiveSlot(\"each\", (placeholder) => {\n    // Capture id from comment node\n    const commentId = placeholder.textContent?.replace(\"naf-\", \"\") || \"0\";\n\n    const stopEffect = effect(() => {\n      components.forEach((c) => c.unmount?.());\n      components = [];\n\n      const itemsArray = items();\n      const html = itemsArray\n        .map((item, i) => {\n          const comp = render(item, () => i);\n          components.push(comp);\n          return comp.html;\n        })\n        .join(\"\");\n\n      updateSlotContent(placeholder, commentId, html);\n      components.forEach((c) => c.mount(placeholder.parentNode as Element));\n    });\n\n    return () => {\n      stopEffect();\n      components.forEach((c) => c.unmount?.());\n    };\n  });\n}\n\n/**\n * Reactively binds a value to an element attribute.\n * Handles boolean attributes, string values, and removal.\n *\n * Value handling:\n * - `true`: Sets attribute with empty string (boolean attribute)\n * - `false` or `null`: Removes the attribute\n * - string: Sets attribute with that value\n *\n * @param el - The element to update\n * @param name - The attribute name\n * @param value - A function that returns the attribute value\n * @returns Cleanup function to stop the effect\n *\n * @example\n * // Boolean attribute (disabled)\n * const isDisabled = signal(false);\n * attr(button, 'disabled', () => isDisabled());\n *\n * @example\n * // String attribute\n * const label = signal('Click me');\n * attr(button, 'aria-label', () => label());\n *\n * @example\n * // Conditional attribute\n * attr(button, 'disabled', () => !isValid());\n * attr(input, 'required', () => isRequired());\n */\nexport function attr(\n  el: Element | null | undefined,\n  name: string,\n  value: () => string | boolean | null,\n): () => void {\n  if (!el) return () => {};\n\n  return effect(() => {\n    const v = value();\n    if (v === false || v === null) {\n      el.removeAttribute(name);\n    } else if (v === true) {\n      el.setAttribute(name, \"\");\n    } else {\n      el.setAttribute(name, String(v));\n    }\n  });\n}\n\n// ============================================================================\n// DOM UTILITIES\n// ============================================================================\n\n/**\n * Short alias for querySelector.\n *\n * @example\n * const input = $(el, 'input[type=\"text\"]');\n */\nexport function $<T extends Element = Element>(\n  root: Element | Document,\n  selector: string,\n): T | null {\n  return root.querySelector<T>(selector);\n}\n\n/**\n * Short alias for querySelectorAll that returns an array.\n * Enables use of array methods like map, filter, find, etc.\n *\n * @example\n * const buttons = $$(el, 'button');\n * buttons.map(btn => btn.textContent);\n */\nexport function $$<T extends Element = Element>(\n  root: Element | Document,\n  selector: string,\n): T[] {\n  return Array.from(root.querySelectorAll<T>(selector));\n}\n\n/**\n * Finds an element and attaches an event listener.\n * Returns the element for chaining or further use.\n *\n * @example\n * $on(el, 'button', 'click', () => handleClick());\n *\n * @example\n * // Chaining to nested elements\n * const form = $on(el, 'form', 'submit', handleSubmit);\n * if (form) {\n *   $on(form, 'input', 'change', handleChange);\n * }\n */\nexport function $on<T extends Element = Element>(\n  root: Element,\n  selector: string,\n  event: string,\n  handler: (e: Event) => void,\n): T | null {\n  const el = root.querySelector<T>(selector);\n  if (el) el.addEventListener(event, handler);\n  return el;\n}\n\n/**\n * Creates two-way binding between an input element and a signal.\n * Sets initial value, listens to input events, and optionally syncs signal changes back to input.\n *\n * @param root - The root element to search within\n * @param selector - CSS selector for the input element\n * @param sig - The signal to bind to\n * @param options - Optional configuration\n * @returns The input element or null if not found\n *\n * @example\n * const text = signal('');\n * model(el, 'input', text);\n *\n * @example\n * // With reactive sync (updates input when signal changes externally)\n * model(el, 'input', text, { reactive: true });\n *\n * @example\n * // For checkboxes\n * const checked = signal(false);\n * model(el, 'input[type=\"checkbox\"]', checked, { type: 'checkbox' });\n */\nexport function model<\n  T extends HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement,\n>(\n  root: Element,\n  selector: string,\n  sig: { (): any; (value: any): any },\n  options?: { reactive?: boolean; type?: \"text\" | \"checkbox\" | \"radio\" },\n): T | null {\n  const el = root.querySelector<T>(selector);\n  if (!el) return null;\n\n  const type = options?.type || \"text\";\n\n  // Set initial value\n  if (type === \"checkbox\" && el instanceof HTMLInputElement) {\n    el.checked = sig();\n  } else if (\"value\" in el) {\n    el.value = sig();\n  }\n\n  // Listen to changes\n  const eventType = type === \"checkbox\" ? \"change\" : \"input\";\n  el.addEventListener(eventType, () => {\n    if (type === \"checkbox\" && el instanceof HTMLInputElement) {\n      sig(el.checked);\n    } else if (\"value\" in el) {\n      sig(el.value);\n    }\n  });\n\n  // Optional: Keep input synced with signal changes\n  if (options?.reactive) {\n    effect(() => {\n      const value = sig();\n      if (type === \"checkbox\" && el instanceof HTMLInputElement) {\n        el.checked = value;\n      } else if (\"value\" in el && el.value !== value) {\n        el.value = value;\n      }\n    });\n  }\n\n  return el;\n}\n\n/**\n * Reactively toggles CSS classes on an element based on a condition.\n * Automatically adds/removes the class when the condition changes.\n *\n * @param el - The element to toggle classes on\n * @param className - The CSS class name to toggle\n * @param condition - A function that returns true to add the class, false to remove it\n * @returns Cleanup function to stop the effect\n *\n * @example\n * const isActive = signal(false);\n * toggleClass(button, 'active', () => isActive());\n *\n * @example\n * // Multiple classes\n * toggleClass(el, 'disabled', () => !isValid());\n * toggleClass(el, 'loading', () => isPending());\n */\nexport function toggleClass(\n  el: Element | null | undefined,\n  className: string,\n  condition: () => boolean,\n): () => void {\n  if (!el) return () => {};\n\n  return effect(() => {\n    if (condition()) {\n      el.classList.add(className);\n    } else {\n      el.classList.remove(className);\n    }\n  });\n}\n\n/**\n * @deprecated Use `attr()` instead. This will be removed in a future version.\n * @example\n * // Old: toggleAttr(button, 'disabled', 'disabled', () => isDisabled())\n * // New: attr(button, 'disabled', () => isDisabled())\n */\nexport function toggleAttr(\n  el: Element | null | undefined,\n  attrName: string,\n  value: string,\n  condition: () => boolean,\n): () => void {\n  return attr(el, attrName, () => (condition() ? value || true : false));\n}\n\n/**\n * Reactively binds a value to an element's textContent.\n * Automatically updates the text when the getter returns a new value.\n *\n * @param el - The element to update\n * @param getter - A function that returns the text value\n * @returns Cleanup function to stop the effect\n *\n * @example\n * const count = signal(0);\n * setText(counterEl, () => count());\n *\n * @example\n * const name = signal('World');\n * setText(greetingEl, () => `Hello, ${name()}!`);\n */\nexport function setText(\n  el: Element | null | undefined,\n  getter: () => any,\n): () => void {\n  if (!el) return () => {};\n\n  return effect(() => {\n    el.textContent = String(getter());\n  });\n}\n\n// ============================================================================\n// ROUTER\n// ============================================================================\n\n/** Configuration options for the router */\nexport interface RouterOptions {\n  /** The root element to mount pages into */\n  root: Element;\n  /** Route definitions mapping hash paths to page factories */\n  routes: Record<string, () => Component>;\n  /** Optional component to show when no route matches */\n  notFound?: () => Component;\n}\n\n/** Router instance returned by createRouter */\nexport interface Router {\n  /** Navigate programmatically to a route */\n  navigate: (path: string) => void;\n  /** Get the current route path */\n  current: () => string;\n  /** Stop the router and clean up event listeners */\n  destroy: () => void;\n}\n\n/**\n * Creates a hash-based router for single-page applications.\n *\n * The router:\n * - Uses hash-based routing (#/path) for compatibility\n * - Automatically handles browser navigation (back/forward)\n * - Cleans up previous page before mounting new one\n *\n * @example\n * const router = createRouter({\n *   root: document.querySelector('#app')!,\n *   routes: {\n *     '#/': HomePage,\n *     '#/about': AboutPage,\n *     '#/todos': TodoPage,\n *   },\n *   notFound: () => template`<h1>404</h1>`,\n * });\n */\nexport function createRouter(options: RouterOptions): Router {\n  const { root, routes, notFound } = options;\n  let currentPage: Component | null = null;\n\n  const current = () => window.location.hash || \"#/\";\n\n  const handleRoute = () => {\n    currentPage?.unmount?.();\n    const factory = routes[current()] ?? notFound;\n\n    if (factory) {\n      currentPage = factory();\n      root.innerHTML = currentPage.html;\n      currentPage.mount(root);\n    } else {\n      currentPage = null;\n      root.innerHTML = `<h1>Page Not Found</h1>`;\n    }\n  };\n\n  const navigate = (path: string) => {\n    window.location.hash = path;\n  };\n\n  window.addEventListener(\"hashchange\", handleRoute);\n  window.addEventListener(\"load\", handleRoute);\n\n  if (document.readyState === \"complete\") {\n    handleRoute();\n  }\n\n  const destroy = () => {\n    window.removeEventListener(\"hashchange\", handleRoute);\n    window.removeEventListener(\"load\", handleRoute);\n    currentPage?.unmount?.();\n    currentPage = null;\n  };\n\n  return { navigate, current, destroy };\n}\n","import { template, Component } from \"../../../naf\";\n\nexport function Card(props: {\n  children: Component | string;\n  className?: string;\n}): Component {\n  return template /*html*/ `\n    <div class=\"card ${props.className || \"\"}\">${props.children}</div>\n  `;\n}\n","import { template, Component } from \"../../../naf\";\nimport { Card } from \"./Card\";\n\nexport function Home(): Component {\n  return template /*html*/ `\n    <div class=\"home\">\n      <h1>NAF</h1>\n      <p class=\"tagline\">Not A Framework - Vanilla SPA Helper Functions</p>\n\n      ${Card({\n        children: template /*html*/ `\n          <div class=\"about-section\">\n            <h2>What is NAF?</h2>\n            <p>\n              NAF is a ~1.6KB gzipped collection of helper functions for building\n              single-page applications with vanilla JavaScript/TypeScript.\n              No virtual DOM, no build step required, just copy and use.\n            </p>\n          </div>\n        `,\n      })}\n\n      ${Card({\n        children: template /*html*/ `\n          <div class=\"features-section\">\n            <h2>Features</h2>\n            <ul>\n              <li><strong>Reactive Signals</strong> - Fine-grained reactivity without a virtual DOM</li>\n              <li><strong>Computed Values</strong> - Automatic dependency tracking and caching</li>\n              <li><strong>Effects</strong> - Side effects that re-run when dependencies change</li>\n              <li><strong>Template Literals</strong> - Build components with tagged templates</li>\n              <li><strong>Conditional Rendering</strong> - <code>when()</code> for reactive conditionals</li>\n              <li><strong>List Rendering</strong> - <code>each()</code> for reactive lists</li>\n              <li><strong>Routing</strong> - Hash-based SPA routing built-in</li>\n            </ul>\n          </div>\n        `,\n      })}\n\n      ${Card({\n        children: template /*html*/ `\n          <div class=\"philosophy-section\">\n            <h2>Philosophy</h2>\n            <p>\n              Copy-first, not install-first. NAF is designed to be copied directly\n              into your project. No npm install, no dependency management, no\n              version conflicts. Just one file you own and can modify.\n            </p>\n          </div>\n        `,\n      })}\n\n      ${Card({\n        children: template /*html*/ `\n          <div class=\"try-section\">\n            <h2>Try It</h2>\n            <p>\n              Check out the <a href=\"#/todos\">Todo App</a> to see NAF in action.\n            </p>\n          </div>\n        `,\n      })}\n    </div>\n  `;\n}\n","export function Header(): string {\n  return /*html*/ `\n    <h1>Todo App</h1>\n  `;\n}\n","import { Signal, template, $, $on, model, attr, Component } from \"../../../naf\";\nimport { Card } from \"./Card\";\n\nexport function AddTodoForm(props: {\n  newTodoText: Signal<string>;\n  onAdd: () => void;\n}): Component {\n  return Card({\n    children: template({\n      root: \".add-todo-form\",\n      onMount(el) {\n        const button = $<HTMLButtonElement>(el, \"button\");\n\n        model(el, \"input\", props.newTodoText, { reactive: true });\n\n        $on(el, \"input\", \"keydown\", (e) => {\n          if (\n            (e as KeyboardEvent).key === \"Enter\" &&\n            props.newTodoText().trim()\n          ) {\n            props.onAdd();\n          }\n        });\n\n        $on(el, \"button\", \"click\", () => {\n          if (props.newTodoText().trim()) {\n            props.onAdd();\n          }\n        });\n\n        attr(button, \"disabled\", () => !props.newTodoText().trim());\n      },\n    }) /*html*/ `\n      <div class=\"add-todo-form\">\n        <input\n          type=\"text\"\n          placeholder=\"What needs to be done?\"\n          autofocus\n        />\n        <button>Add</button>\n      </div>\n    `,\n  });\n}\n","import { Signal, template, $$, toggleClass, Component } from \"../../../naf\";\nimport { Filter } from \"./types\";\nimport { Card } from \"./Card\";\n\nexport function FilterButtons(props: {\n  currentFilter: Signal<Filter>;\n}): Component {\n  return Card({\n    children: template({\n      root: \".filters\",\n      onMount(el) {\n        const buttons = $$(el, \"button\");\n\n        buttons.forEach((btn) => {\n          btn.addEventListener(\"click\", () => {\n            const filterValue = btn.getAttribute(\"data-filter\") as Filter;\n            props.currentFilter(filterValue);\n          });\n\n          const filterValue = btn.getAttribute(\"data-filter\");\n          toggleClass(\n            btn,\n            \"active\",\n            () => props.currentFilter() === filterValue,\n          );\n        });\n      },\n    }) /*html*/ `\n      <div class=\"filters\">\n        <button class=\"secondary\" data-filter=\"all\">All</button>\n        <button class=\"secondary\" data-filter=\"active\">Active</button>\n        <button class=\"secondary\" data-filter=\"completed\">Completed</button>\n      </div>\n    `,\n  });\n}\n","import { template, text, $on, toggleClass, Component } from \"../../../naf\";\nimport { Todo } from \"./types\";\n\nexport function TodoItem(props: {\n  todo: Todo;\n  onToggle: (id: number) => void;\n  onDelete: (id: number) => void;\n}): Component {\n  return template({\n    root: `[data-id=\"${props.todo.id}\"]`,\n    onMount(el) {\n      $on(el, 'input[type=\"checkbox\"]', \"change\", () =>\n        props.onToggle(props.todo.id),\n      );\n      $on(el, \".delete-btn\", \"click\", () => props.onDelete(props.todo.id));\n      toggleClass(el, \"done\", () => props.todo.done);\n    },\n  }) /*html*/ `\n    <div class=\"todo-item\" data-id=\"${props.todo.id}\">\n      <input type=\"checkbox\" ${props.todo.done ? \"checked\" : \"\"} />\n      <span class=\"todo-text\">${text(props.todo.text)}</span>\n      <button class=\"danger delete-btn\">Delete</button>\n    </div>\n  `;\n}\n","import { template, each, Component } from \"../../../naf\";\nimport { Todo } from \"./types\";\nimport { Card } from \"./Card\";\nimport { TodoItem } from \"./TodoItem\";\n\nexport function TodoList(props: {\n  todos: Todo[];\n  onToggle: (id: number) => void;\n  onDelete: (id: number) => void;\n}): Component {\n  return Card({\n    children: template /*html*/ `\n      <div class=\"todo-list\">\n        ${each(\n          () => props.todos,\n          (todo) =>\n            TodoItem({\n              todo,\n              onToggle: props.onToggle,\n              onDelete: props.onDelete,\n            }),\n        )}\n      </div>\n    `,\n  });\n}\n","import { template, Component } from \"../../../naf\";\nimport { Filter } from \"./types\";\nimport { Card } from \"./Card\";\n\nexport function EmptyState(props: { filter: Filter }): Component {\n  const messages: Record<Filter, string> = {\n    all: \"No todos yet! Add one above to get started.\",\n    active: \"No active todos! All done!\",\n    completed: \"No completed todos yet. Keep working!\",\n  };\n\n  return Card({\n    className: \"empty-state\",\n    children: /*html*/ `\n      <div class=\"empty-content\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n          <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n        </svg>\n        <p>${messages[props.filter]}</p>\n      </div>\n    `,\n  });\n}\n","import { Computed, template, $, setText, Component } from \"../../../naf\";\nimport { Card } from \"./Card\";\n\nexport function Stats(props: {\n  activeCount: Computed<number>;\n  totalCount: Computed<number>;\n}): Component {\n  return Card({\n    className: \"stats\",\n    children: template({\n      root: \".stats-content\",\n      onMount(el) {\n        const activeEl = $<HTMLElement>(el, \".stat:first-child strong\");\n        const activeLabel = $<HTMLElement>(el, \".stat:first-child span\");\n        const totalEl = $<HTMLElement>(el, \".stat:last-child strong\");\n\n        setText(activeEl, props.activeCount);\n        setText(activeLabel, () => {\n          const active = props.activeCount();\n          return active === 1 ? \"task remaining\" : \"tasks remaining\";\n        });\n        setText(totalEl, props.totalCount);\n      },\n    }) /*html*/ `\n      <div class=\"stats-content\">\n        <div class=\"stat\">\n          <strong>0</strong>\n          <span>tasks remaining</span>\n        </div>\n        <div class=\"stat\">\n          <strong>0</strong>\n          <span>total</span>\n        </div>\n      </div>\n    `,\n  });\n}\n","import { signal, computed, template, when, $, Component } from \"../../../naf\";\nimport { Todo, Filter } from \"./types\";\nimport { Header } from \"./Header\";\nimport { AddTodoForm } from \"./AddTodoForm\";\nimport { FilterButtons } from \"./FilterButtons\";\nimport { TodoList } from \"./TodoList\";\nimport { EmptyState } from \"./EmptyState\";\nimport { Stats } from \"./Stats\";\n\nexport function TodoPage(): Component {\n  // State\n  const todos = signal<Todo[]>([\n    { id: 1, text: \"Learn NAF\", done: false },\n    { id: 2, text: \"Build a todo app\", done: false },\n  ]);\n  const newTodoText = signal(\"\");\n  const filter = signal<Filter>(\"all\");\n\n  // Computed Values\n  const filteredTodos = computed(() => {\n    const all = todos();\n    const f = filter();\n    if (f === \"active\") return all.filter((t) => !t.done);\n    if (f === \"completed\") return all.filter((t) => t.done);\n    return all;\n  });\n\n  const activeCount = computed(() => {\n    return todos().filter((t) => !t.done).length;\n  });\n\n  const totalCount = computed(() => {\n    return todos().length;\n  });\n\n  // Actions\n  const addTodo = () => {\n    const text = newTodoText().trim();\n    if (!text) return;\n\n    todos([...todos(), { id: Date.now(), text, done: false }]);\n    newTodoText(\"\");\n\n    setTimeout(() => {\n      $<HTMLInputElement>(document, \".add-todo-form input\")?.focus();\n    }, 0);\n  };\n\n  const toggleTodo = (id: number) => {\n    todos(todos().map((t) => (t.id === id ? { ...t, done: !t.done } : t)));\n  };\n\n  const deleteTodo = (id: number) => {\n    todos(todos().filter((t) => t.id !== id));\n  };\n\n  // Render\n  return template /*html*/ `\n    <div class=\"app\">\n      ${Header()}\n      ${AddTodoForm({ newTodoText, onAdd: addTodo })}\n      ${FilterButtons({ currentFilter: filter })}\n      ${when(\n        () => filteredTodos(),\n        (filtered) =>\n          TodoList({\n            todos: filtered,\n            onToggle: toggleTodo,\n            onDelete: deleteTodo,\n          }),\n        () => EmptyState({ filter: filter() }),\n      )}\n\n      <div class=\"stats-wrapper\">\n          ${Stats({ activeCount, totalCount })}\n      </div>\n  `;\n}\n","import { template, Component } from \"../../../naf\";\n\nexport function Nav(): Component {\n  return template /*html*/ `\n    <nav class=\"main-nav\">\n      <a href=\"#/\">Home</a>\n      <a href=\"#/todos\">Todos</a>\n    </nav>\n  `;\n}\n","import { createRouter, template } from \"../../naf\";\nimport { Home } from \"./components/Home\";\nimport { TodoPage } from \"./components/TodoPage\";\nimport { Nav } from \"./components/Nav\";\n\nconst root = document.querySelector(\"#app\");\nif (!root) {\n  throw new Error(\"Could not find #app element\");\n}\n\n// Wrap pages with nav\nfunction withNav(page: () => ReturnType<typeof template>) {\n  return () => template /*html*/ `\n    <div class=\"layout\">\n      ${Nav()}\n      <main>\n        ${page()}\n      </main>\n    </div>\n  `;\n}\n\ncreateRouter({\n  root,\n  routes: {\n    \"#/\": withNav(Home),\n    \"#/todos\": withNav(TodoPage),\n  },\n  notFound: withNav(\n    () => template /*html*/ `\n    <div class=\"not-found\">\n      <h1>404</h1>\n      <p>Page not found</p>\n      <a href=\"#/\">Go Home</a>\n    </div>\n  `,\n  ),\n});\n"],"names":["activeSub","activeSets","track","subs","notify","fn","signal","initialValue","value","newValue","computed","dirty","markDirty","prevSub","effect","running","subscribedTo","run","set","prevSets","text","str","isComponent","buildTemplate","strings","values","components","parts","i","createComponent","html","options","component","parent","c","foundEl","_a","_b","slotId","tempDiv","updateSlotContent","placeholder","commentId","node","end","next","reactiveSlot","dataAttr","setupEffect","id","cleanup","walker","endMarker","template","optionsOrStrings","valuesOrNothing","when","condition","then","otherwise","currentComponent","stopEffect","each","items","render","item","comp","attr","el","name","v","$","root","selector","$$","$on","event","handler","model","sig","type","eventType","toggleClass","className","setText","getter","createRouter","routes","notFound","currentPage","current","handleRoute","factory","navigate","path","Card","props","Home","Header","AddTodoForm","button","e","FilterButtons","btn","filterValue","TodoItem","TodoList","todo","EmptyState","Stats","activeEl","activeLabel","totalEl","TodoPage","todos","newTodoText","filter","filteredTodos","all","f","t","activeCount","totalCount","addTodo","toggleTodo","deleteTodo","filtered","Nav","withNav","page"],"mappings":"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"}